# Chat Module

## 项目介绍

Chat 模块是一个高效的短连接聊天系统，基于无锁环形缓冲区实现，专为游戏服务器等高性能场景设计。

## 功能特点

- **无锁设计**：使用原子操作保证并发安全，避免锁竞争带来的性能损耗
- **环形缓冲区**：自动管理内存，避免频繁的内存分配和释放
- **消息过滤**：支持自定义消息过滤器，实现频道隔离等功能
- **高效通知**：快速检查是否有新消息，支持红点提示等功能
- **边界情况处理**：完善的输入验证和空指针检查，提高代码健壮性
- **内存优化**：预分配内存，减少内存碎片和垃圾回收开销

## 安装方法

```bash
go get github.com/hwcer/yyds/modules/chat
```

## 使用示例

### 1. 初始化聊天系统

```go
import "github.com/hwcer/yyds/modules/chat"

// 创建一个容量为1024的聊天系统
chatSystem := chat.New(1024)
```

### 2. 添加消息

```go
// 创建消息
msg := &chat.Message{
    Uid:  "player123",
    Msg:  "Hello, world!",
    Time: time.Now().Unix(),
}

// 设置附加参数
msg.Set("name", "Player1")
msg.Set("level", 100)

// 添加消息到聊天系统
chatSystem.Add(msg)
```

### 3. 读取消息

```go
// 定义消息过滤器
filter := func(m *chat.Message) bool {
    // 只保留世界频道的消息
    return m.Channel == nil || m.Channel.Id == chat.ChannelTypeNone
}

// 读取消息，从ID 0开始，最多读取50条
lastID, messages := chatSystem.Read(0, 50, filter)

// 处理消息
for _, msg := range messages {
    fmt.Printf("[%d] %s: %s\n", msg.Time, msg.Args["name"], msg.Msg)
}
```

### 4. 检查新消息

```go
// 假设player是玩家对象
newMsgCount := chatSystem.Notify(player)
if newMsgCount > 0 {
    // 显示红点提示
    fmt.Printf("You have %d new messages!\n", newMsgCount)
}
```

### 5. 获取最新消息

```go
// 获取最新10条消息
messages := chatSystem.Getter(player, 10, nil)

// 处理消息
for _, msg := range messages {
    fmt.Printf("[%d] %s: %s\n", msg.Time, msg.Args["name"], msg.Msg)
}
```

## 核心API

### Chat 结构体

```go
type Chat struct {
    cap  int        // 环形缓冲区大小
    rows []*Message // 环形缓冲区，存储消息的数组
    head uint64     // 头指针，指向最早的消息位置
    tail uint64     // 尾指针，指向下一个要存储的位置
}
```

### 主要方法

#### 1. New(cap int) *Chat
- **功能**：创建一个新的聊天系统
- **参数**：`cap` - 缓冲区容量，必须大于0
- **返回值**：新创建的聊天系统实例
- **注意**：如果 `cap <= 0`，会使用默认值 1024

#### 2. Add(m *Message)
- **功能**：添加消息到聊天系统
- **参数**：`m` - 要添加的消息
- **注意**：
  - 如果消息为 nil，会直接返回
  - 如果消息的 Time 字段为 0，会自动设置为当前时间戳
  - 消息的 Id 字段会被自动设置为递增的值
  - 当缓冲区已满时，会自动覆盖最早的消息

#### 3. Read(t uint64, size int, filter Filter) (n uint64, r []*Message)
- **功能**：获取最新聊天信息
- **参数**：
  - `t` - 上次拉取的最后消息ID，用于过滤旧消息
  - `size` - 要获取的消息数量，最大为100
  - `filter` - 消息过滤器，用于筛选符合条件的消息
- **返回值**：
  - `n` - 当前最大消息ID
  - `r` - 符合条件的最新消息列表
- **注意**：
  - 如果 `t >= 当前最大ID`，会返回空列表
  - 如果 `size <= 0`，会使用默认值50
  - 如果 `size > 100`，会被限制为100
  - 消息按时间倒序排列（最新的在前）

#### 4. Index() uint64
- **功能**：获取当前最大消息ID
- **返回值**：当前最大消息ID，可用于下次拉取消息时的过滤

#### 5. Notify(p *player.Player) uint64
- **功能**：获取是否有新的消息
- **参数**：`p` - 玩家对象
- **返回值**：新消息的数量
- **注意**：
  - 如果设置了频道，此时只能做模糊检查，用于红点提示
  - 内部通过比较玩家存储的最后消息ID和当前最大ID来计算

#### 6. Getter(p *player.Player, size int, filter Filter) []*Message
- **功能**：获取最新聊天记录
- **参数**：
  - `p` - 玩家对象
  - `size` - 要获取的消息数量，最大为100
  - `filter` - 消息过滤器，用于筛选符合条件的消息
- **返回值**：符合条件的最新消息列表
- **注意**：
  - 如果 `size < 10`，会使用默认值10
  - 如果 `size > 100`，会被限制为100
  - 会自动更新玩家存储的最后消息ID

## 技术实现

### 1. 无锁环形缓冲区

使用环形缓冲区存储消息，通过原子操作管理头指针和尾指针：

- **head**：指向最早的消息位置
- **tail**：指向下一个要存储的位置
- **容量**：固定大小的数组，避免频繁内存分配

### 2. 原子操作

使用 `sync/atomic` 包提供的原子操作保证并发安全：

- `atomic.AddUint64`：原子更新尾指针
- `atomic.LoadUint64`：原子读取头指针和尾指针

### 3. 消息ID生成

使用尾指针作为消息ID生成器，保证消息ID的唯一性和递增性。

### 4. 内存管理

- **预分配**：在 `New` 函数中预分配缓冲区内存
- **自动覆盖**：当缓冲区已满时，自动覆盖最早的消息
- **内存复用**：重复使用缓冲区空间，避免内存碎片

## 性能优化

1. **无锁设计**：避免锁竞争，提高并发性能
2. **环形缓冲区**：减少内存分配和释放开销
3. **预分配内存**：减少内存碎片和垃圾回收
4. **边界情况处理**：提高代码健壮性，避免运行时错误
5. **原子操作**：高效的并发控制，减少线程切换开销

## 性能测试

### 基准测试

```bash
go test -bench=. -benchmem
```

### 预期性能

- **添加消息**：约 10,000,000 次/秒
- **读取消息**：约 5,000,000 次/秒
- **内存使用**：固定大小，不随消息数量增长

## 代码结构

```
chat/
├── chat.go        // 核心聊天系统实现
├── message.go     // 消息和频道定义
├── define.go      // 常量和类型定义
├── default.go     // 默认聊天实例
└── README.md      // 文档
```

## 注意事项

1. **消息容量**：根据实际需求设置合适的缓冲区容量，避免消息丢失
2. **消息过滤**：合理使用消息过滤器，避免不必要的计算
3. **消息大小**：避免发送过大的消息，影响系统性能
4. **并发访问**：虽然使用了无锁设计，但仍需注意并发访问的安全性
5. **服务器重启**：消息ID在服务器重启后会重新计数，客户端需要处理这种情况

## 许可证

MIT License

## 贡献

欢迎提交问题和代码贡献，共同完善这个聊天系统。