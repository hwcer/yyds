# Chat Module

## 项目介绍

Chat 模块是一个高效的短连接聊天系统，基于无锁环形缓冲区实现，专为游戏服务器等高性能场景设计。

## 功能特点

- **无锁设计**：使用原子操作保证并发安全，避免锁竞争带来的性能损耗
- **环形缓冲区**：自动管理内存，避免频繁的内存分配和释放
- **消息过滤**：支持自定义消息过滤器，实现频道隔离等功能
- **高效通知**：快速检查是否有新消息，支持红点提示等功能
- **边界情况处理**：完善的输入验证和空指针检查，提高代码健壮性
- **内存优化**：预分配内存，减少内存碎片和垃圾回收开销

## 安装方法

```bash
go get github.com/hwcer/yyds/modules/chat
```

## 使用示例

### 1. 初始化聊天系统

```go
import "github.com/hwcer/yyds/modules/chat"

// 创建一个容量为1024的聊天系统
chatSystem := chat.New(1024, nil)

// 或者使用默认容量
chatSystem := chat.New(0, nil) // 会使用DefaultCap
```

### 2. 配置默认值

```go
// 设置默认配置
chat.DefaultCap = 2048  // 默认缓冲区容量
chat.DefaultSize = 150  // 默认读取消息数量
```

### 3. 添加消息

```go
// 创建频道信息（可选）
channel := &chat.Channel{
    Key: "world", // 频道类型
    Val: "",      // 频道ID
}

// 添加消息到聊天系统
message, err := chat.Send("Hello, world!", map[string]any{
    "name": "Player1",
    "level": 100,
}, channel)
```

### 4. 读取消息

```go
// 定义消息过滤器
filter := func(m chat.Message) bool {
    // 只保留世界频道的消息
    return true
}

// 读取消息，从ID 0开始，最多读取100条
lastID, messages := chatSystem.Read(0, 100, filter)

// 处理消息
for _, msg := range messages {
    // 处理消息
}
```

### 5. 检查新消息

```go
// 假设player是玩家对象
newMsgCount := chatSystem.Notify(player)
if newMsgCount > 0 {
    // 显示红点提示
    fmt.Printf("You have %d new messages!\n", newMsgCount)
}
```

### 6. 获取最新消息

```go
// 获取最新消息
messages := chatSystem.Getter(player, 50, nil)

// 处理消息
for _, msg := range messages {
    // 处理消息
}
```

## 核心API

### Chat 结构体

```go
type Chat struct {
    cap     int       // 环形缓冲区大小
    rows    []Message // 环形缓冲区，存储消息的数组
    head    uint64    // 头指针，指向最早的消息位置
    tail    uint64    // 尾指针，指向下一个要存储的位置
    factory Factory   // 用户工厂函数
}
```

### 主要方法

#### 1. New(cap int, factory Factory) *Chat
- **功能**：创建一个新的聊天系统
- **参数**：
  - `cap` - 缓冲区容量，必须大于0
  - `factory` - 消息工厂，用于创建消息实例
- **返回值**：新创建的聊天系统实例
- **注意**：
  - 如果 `cap <= 0`，会使用默认值 `DefaultCap`
  - 如果 `factory == nil`，会使用默认工厂

#### 2. Write(text string, args map[string]any, channel *Channel) Message
- **功能**：添加消息到聊天系统
- **参数**：
  - `text` - 消息内容
  - `args` - 附加参数
  - `channel` - 频道信息
- **返回值**：创建的消息对象
- **注意**：
  - 消息的 Id 字段会被自动设置为递增的值
  - 当缓冲区已满时，会自动覆盖最早的消息
  - 消息的生命周期由缓冲区大小和写入速度决定

#### 3. Read(t uint64, size int, filter Filter) (n uint64, r []Message)
- **功能**：获取最新聊天信息
- **参数**：
  - `t` - 上次拉取的最后消息ID，用于过滤旧消息
  - `size` - 要获取的消息数量
  - `filter` - 消息过滤器，用于筛选符合条件的消息
- **返回值**：
  - `n` - 当前最大消息ID
  - `r` - 符合条件的最新消息列表
- **注意**：
  - 如果 `t >= 当前最大ID`，会返回空列表
  - 如果 `size <= 0` 或 `size > DefaultSize`，会使用默认值 `DefaultSize`
  - 消息按时间倒序排列（最新的在前）

#### 4. Notify(p *player.Player) uint64
- **功能**：获取是否有新的消息
- **参数**：`p` - 玩家对象
- **返回值**：新消息的数量
- **注意**：
  - 如果设置了频道，此时只能做模糊检查，用于红点提示
  - 内部通过比较玩家存储的最后消息ID和当前最大ID来计算
  - 此方法是无锁的，适用于高频调用场景

#### 5. Getter(p *player.Player, size int, filter Filter) []Message
- **功能**：获取最新聊天记录
- **参数**：
  - `p` - 玩家对象
  - `size` - 要获取的消息数量
  - `filter` - 消息过滤器，用于筛选符合条件的消息
- **返回值**：符合条件的最新消息列表
- **注意**：
  - 会自动更新玩家存储的最后消息ID
  - 此方法依赖于Read方法的无锁实现

### 辅助方法

#### 1. Send(text string, args map[string]any, channel *Channel) (Message, error)
- **功能**：发送聊天消息
- **参数**：
  - `text` - 消息内容
  - `args` - 附加参数
  - `channel` - 频道信息
- **返回值**：
  - 创建的消息对象
  - 错误信息
- **注意**：
  - 消息内容不能为空且不能超过300字节
  - 消息内容不能包含非法字符

#### 2. Getter(p *player.Player, size int, filter Filter) []Message
- **功能**：获取最新聊天记录
- **参数**：
  - `p` - 玩家对象
  - `size` - 要获取的消息数量
  - `filter` - 消息过滤器，用于筛选符合条件的消息
- **返回值**：符合条件的最新消息列表

#### 3. Notify(p *player.Player)
- **功能**：检查是否有新消息
- **参数**：`p` - 玩家对象

## 技术实现

### 1. 无锁环形缓冲区

使用环形缓冲区存储消息，通过原子操作管理头指针和尾指针：

- **head**：指向最早的消息位置
- **tail**：指向下一个要存储的位置
- **容量**：固定大小的数组，避免频繁内存分配
- **默认容量**：`DefaultCap`，可配置

### 2. 原子操作

使用 `sync/atomic` 包提供的原子操作保证并发安全：

- `atomic.AddUint64`：原子更新尾指针
- `atomic.LoadUint64`：原子读取头指针和尾指针

### 3. 消息ID生成

使用尾指针作为消息ID生成器，保证消息ID的唯一性和递增性。

### 4. 内存管理

- **预分配**：在 `New` 函数中预分配缓冲区内存
- **自动覆盖**：当缓冲区已满时，自动覆盖最早的消息
- **内存复用**：重复使用缓冲区空间，避免内存碎片

### 5. 默认值配置

提供可配置的默认值：

- `DefaultCap`：默认缓冲区容量，默认值为 1024
- `DefaultSize`：默认读取消息数量，默认值为 100

### 6. 消息工厂

使用工厂模式创建消息实例：

- 默认工厂：创建默认消息实例
- 自定义工厂：支持用户自定义消息结构

## 性能优化

1. **无锁设计**：避免锁竞争，提高并发性能
2. **环形缓冲区**：减少内存分配和释放开销
3. **预分配内存**：减少内存碎片和垃圾回收
4. **边界情况处理**：提高代码健壮性，避免运行时错误
5. **原子操作**：高效的并发控制，减少线程切换开销
6. **可配置默认值**：根据实际需求调整系统参数
7. **消息工厂**：支持自定义消息结构，提高灵活性

## 性能测试

### 基准测试

```bash
go test -bench=. -benchmem
```

### 预期性能

- **添加消息**：约 10,000,000 次/秒
- **读取消息**：约 5,000,000 次/秒
- **内存使用**：固定大小，不随消息数量增长
- **并发性能**：支持高并发场景，适用于游戏服务器等实时应用

## 代码结构

```
chat/
├── chat.go        // 核心聊天系统实现
├── define.go      // 常量和类型定义
├── message.go     // 消息和频道定义
├── default.go     // 默认聊天实例
└── README.md      // 文档
```

## 注意事项

1. **消息容量**：根据实际需求设置合适的缓冲区容量，避免消息丢失
2. **消息过滤**：合理使用消息过滤器，避免不必要的计算
3. **消息大小**：避免发送过大的消息，影响系统性能
4. **并发访问**：虽然使用了无锁设计，但仍需注意并发访问的安全性
5. **服务器重启**：消息ID在服务器重启后会重新计数，客户端需要处理这种情况
6. **默认值配置**：根据实际需求调整默认值配置，优化系统性能
7. **消息生命周期**：消息的生命周期由缓冲区大小和写入速度决定，需要合理设置缓冲区容量

## 许可证

MIT License

## 贡献

欢迎提交问题和代码贡献，共同完善这个聊天系统。